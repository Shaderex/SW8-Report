%!TEX root = ../../super_main.tex
\section{Security}


Since the system should be able to handle personal data, there are certain security constraints that we must comply with as described in \secref{sec:personal_data}. For one the legislation states that the personal data must be encrypted at all times, constraining that all ways these data are communicated must also be encrypted. For this reason we utilize an encrypted network protocol (HTTPS) using SSL encryption.

\subsection{Secure Socket Layer}
\label{sub:secure_socket_layer}
Secure Socket Layer (SSL) is a broadly used security technology for creating a secure connection between a client and a server. SSL establishes this secure connection by utilizing both symmetric and asymmetric encryption. Symmetric encryption algorithms use the same encryption key for both the encryption and decryption of the communication, whereas asymmetric encryption encrypts the communication using one key (a public key) and decrypts it using another (private key). 
\\\\
\todo[inline]{Har svært ved at finde en god/akademisk kilde til det her}  
To establish the connection between the client and the server, the client initially sends the server information of how it wishes to communicate, such as what version of SSL/TLS, what cipher suites it supports and how the messages between them should be validated. The server will then chose what version and what algorithms are used in the communication and send it back to client along with its certificate and its public key. The client will then validate the certificate through a Certificate Authority (CA). If it is valid the client will use the public key to encrypt a \mono{PreMasterSecret} that will be used by both the client and the server to create the key for the symmetric encryption algorithm that will be used for further information. The key will be based on both the \mono{PreMasterSecret} as well as some random numbers that have accompanied every request up to this point. The server will then decrypt the \mono{PreMasterSecret} using its private key. The server and the client can then both generate the key used for the symmetric encryption algorithm based on the random numbers and the \mono{PreMasterSecret} and use this for any further communication.
\\\\
For our purposes we have chosen to use what is called a self-signed certificate, because it covered the need for encryption that we had, and the price of a certificate issued by a CA is fairly high. The certificate we use was created by using OpenSSL\footnote{https://www.openssl.org}, which is an open source project that allows you to create your own certificate. 

One of the issues in utilizing a self-signed certificate is that the certificate will not be trusted by most browsers and operating systems. A more severe problem is the fact that it leaves the connection vulnerable to a man in the middle attack, where a third party with malicious intent might intercept the connection and use his own ``fake'' certificate and thereby getting access to potentially sensitive information. This would not be a problem if we had used a certificate issued by a CA, because the certificate then could be validated. 
\todo[inline]{Hvorfor betyder det ikke så meget for os at have en ca?}
Having a self-signed certificate also means that the certificate is not trusted by Android, which has caused 

% 	vi har været nd til at lave vores egen android stuff
% android fixes
% 	domainverifier
% 	trustmanager
% andre problemer vi har haft 
% 	porte åbne ud til
%   hvis vi havde haft flere porte ville vi have kunnet redirect fra http til https
%   Hvis vi havde haft port 80 og port 443 kunne vi have brugt lets encrypt




