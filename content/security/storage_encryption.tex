%!TEX root = ../../super_main.tex

\section{Storage Encryption}
\label{sec:storage_encryption}
% Skriv om at vi skal gemme data sikkert
According to the legislation briefly described in \secref{sub:legislation}, data that can identify individuals must be encrypted. In our case we both need to store data locally on the clients Android device, as well as remotely on a server dedicated to storing the data and showing it to the correct customers, meaning that we will have to consider the security and encryption in two different code bases and on two different platforms. 

\subsection{Local Storage}
\label{sub:local_storage}
We decided to look at different options to ensure, that we could safely store the gathered data on Android devices. Storing the data locally requires a local solution for encrypting all data saved in persistent storage on the device. 
\\\\
Firstly, we considered the SQLite database that is natively supported by Android. The problem with using SQLite is that we would have to create a schema for each of the sensors and their data types, making it a longsome task. The process of adding new sensors would also become more tedious, making the system less adaptable to new sensors. Furthermore to ensure encryption on a SQLite database we would have to use an extension to SQLite called SQLCipher\footnote{https://www.zetetic.net/sqlcipher/} which would allow us to encrypt the database. 
\\\\
Another option that we looked at is android-simple-storage (ASS)\footnote{https://github.com/sromku/android-simple-storage}, which, as the name implies, is a simple library for handling the internal (storage reserved for an application and only accessible through the application it is reserved for) and external (SD card or other shared storage) storage in Android. ASS allowed us a simple interface to this file system while at the same time it made it possible to encrypt the data directly through the library by specifying a few options. We therefore implemented a prototype of this as our main storage for the application. Our prototype was based on JSON as our file format and the GSON library, which provides easy serialization and deserialization of Java objects to and from JSON. A problem arose with this approach. This way of storing our data could not pass one of our acceptance tests stating that:

\begin{itemize}[noitemsep]
 	\item When there exist a snapshot model, which does not use more than 10 MB storage space using all sensors (per device) for one day
	\begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
		\item Snapshot duration: one day
		\item Sample frequency: one minute
		\item Sample duration: 10 seconds
		\item Measurement frequency: 100 milliseconds
	\end{itemize}
\end{itemize}
\todo[inline]{OPDATER ACCEPTANCE TESTS I RAPPORT}

The problem was that we used more than the maximum storage size of 10 MB as stated in the acceptance test. The JSON format had too much overhead, because it utilizes explicit field names instead of a schema, and thus it used more storage space than what should be needed. 
\\\\
This lead us to explore other options, and we came across Realm\footnote{https://realm.io/}, which the developers behind it says should be the replacement for SQLite, and that it should not just be an ORM on top of it. Realm uses its own persistence engine, and is cross-platform (IOS/Android) meaning that the same Realm file can be shared across multiple platforms. Realm natively supports encryption of the data. We ended up choosing Realm for our persistence layer. One of the drawbacks of Realm is that it only supports a single level of inheritance to specify which objects should be able to be stored persistently. All persistent objects must directly be children of a class called \mono{RealmObject} and it is therefore not possibly to create complex inheritance hierarchies with multiple levels of inheritance with abstract classes to help minimize code duplication.  
\\\\
Another drawback is that Realm only supports one aggregate or collection type, namely \mono{RealmList}. Realm does not support types such as maps or enums, forcing us to either serialize and deserialize these types manually or by creating class wrappers that extends \mono{RealmObject}, which could represent the unsupported types.

\lstinputlisting[
   style = Java,
   caption = {An example of how the realm is accessed and objects in it are manipulated.},
   label = {lst:realm_example},
   float,
]{content/security/code_snippets/notifyQuestionnaireCompleted.java}

\todo[inline]{Rikke: This text need some rework, it is quite difficult to understand}
Even though Realm sets up these restrictions it still has a nice API, where one simply can get a previously defined default instance of the access point (\mono{Realm}) in \lineref{lst:get_default_realm} in \lstref{lst:realm_example}. Following this it is possible to utilize the instance to get certain types of object. In this case we are looking for a \mono{Snapshot}, where its timestamp is equal to a given value. In the case such a snapshot exists we want to add a questionnaire with its questions answered to the snapshot, by first adding it to the realm, and then update the snapshot with the given questionnaire set as a field on the snapshot. Similar to the \mono{copyToRealm} and \mono{copyToRealmOrUpdate} there also exists functionality for removing objects from a realm, namely \mono{removeFromRealm} and \mono{removeAllFromRealm}.

\todo[inline]{how does realm do this -- REFLECTION PUHA BESKRIV DET}

The default configuration used in the previous example needs to be set somewhere before any access is attempted from the application. The code responsible for setting the default instance can be seen in \lstref{lst:realm_default}. 

\lstinputlisting[
   style = Java,
   caption = {The algorithm generating encryption keys.},
   label = {lst:realm_default},
   float,
]{content/security/code_snippets/setupRealmAndStartTimers.java}

As shown the code for specifying an instance of a realm is very simple, and a thing such as encryption is handled by just a single line of code, given that the encryption key is known at this point. How we generate and retrieve the encryption key is covered below. 

\subsubsection{Encryption Keys}
\label{sub:encryption_keys}
A requirement when storing sensitive data encrypted is that the encryption key is not stored on the same unit as the data. We initially stored the encryption key in the source code of the application to simplify the encryption of the data. A problem with this approach, and the reason why it is a requirement to store it separately, is that a distributable application, known as an APK file, which is made publicly available, can be decompiled and the encryption key could potentially be extracted. 
\\\\
All that is needed for a potential attacker or malicious application is then to somehow gain access to the internal storage of our application and fetch the Realm file. The internal storage of the application is private, and under normal circumstances the underlying Linux operating system will only grant the application owning the internal storage access to it. This holds unless there is a security hole present, or the user of the device has rooted his device, i.e. is using a privileged account, in which case it is possible to access the internal storage of every application on the device. An application or user with root privileges could then access our storage and with the use of the key found in the decompiled APK and gain access to all the sensitive information that we store on the device.
\\\\
Instead of storing the encryption key on the device we decided to move it to the server, and also ensure that every device has its own encryption key. Having an encryption key for each device requires us to somehow be able to uniquely identify a device. Luckily, as mentioned in \todo{insert secref to GCM} we have a way of generating a unique identifier for each individual device. In having the device identifier it is possible for us to generate a 512 bit random encryption key the first time a device issues requests to our server and then simply return the newly generated key or a stored key if one has already been generated for the given device. This key exchange is of course done over our TLS encrypted connection covered in \secref{sec:transport_layer_security}. We generate the key with the algorithm seen in \lstref{lst:encryption_php}. 

\todo[inline]{Rikke: Make clear that this code snippet is in PHP}
\lstinputlisting[
   style = PHP,
   caption = {The algorithm generating encryption keys.},
   label = {lst:encryption_php},
   float,
]{content/security/code_snippets/encryption.php}

This algorithm utilizes the random number generation features in the Linux kernel, by utilizing a special file, \mono{/dev/urandom} that interfaces the random number generation. Each time this file is read by the algorithm it will return a random byte, making it ideal to generate a sequence of random bytes representing an encryption key. The algorithm firstly create a file pointer to the \mono{/dev/urandom} file with the \mono{fopen} function. The function will return \mono{FALSE} if the file could not be opened, which is checked in \lineref{lst:fp_check}. Next, we will read the number of specified random bytes with the \mono{fread} function, which we will then return back to the call site as a binary string. This key can then be sent to a client if requested. On the Android client the encryption key is expected to be in the format of a byte array, meaning that we will need to convert the binary string into such a data structure. 
\\\\
Luckily, the library that we utilize for making HTTP requests from the Android application has built in support for conversion of binary data into byte arrays very simple as shown in \lstref{lst:binary_to_byte_array}, where we simply send a GET request with the \mono{device\_id} as a parameter. The request that is send will be sent up to three times if the transmission fails, which is specified with the \mono{retry(3, false)} method call. Lastly we utilize the asBytes method to transform the response that we get to a binary array, which is what the body type of the response then will resolve to in the \mono{onResponseCodeMatching} method. In this method we simply can get the converted response body corresponding to the encryption key generated by the server, and utilize this throughout our application to encrypt and decrypt the realm file.    

\lstinputlisting[
   style = Java,
   caption = {Simple example of how we use the Webb library to convert binary strings to an byte array.},
   label = {lst:binary_to_byte_array},
   float,
]{content/security/code_snippets/getEncryptionKey.java}

\subsection{Remote Storage}
\label{sub:remote_storage}

According to the legislation the data on the server should also be encrypted. However, due to limited limited time and prioritization of functionality over security, we have not been able to implement proper encryption of the data on the remote storage. We are utilizing PostgreSQL and it has some support for encryption that may fit our needs, however, the connection to the database is currently managed through an ORM, which might complicate the task of decrypting the data before it is used in the application. To be able to release this product we would have to implement encryption on the back end as well to meet the statutory demands.
