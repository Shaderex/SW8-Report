%!TEX root = ../../super_main.tex

\section{Storage Encryption}
\label{sec:storage_encryption}
% Skriv om at vi skal gemme data sikkert
According to the legislation briefly described in \secref{sub:legislation} the data that can identify individuals should be encrypted. In our case we both need to store data locally on the clients Android device, as well as remotely on a server dedicated to storing the data and showing it to the correct customers, meaning that we will have to consider the security and encryption in two different code bases. 

\subsection{Local Storage}
\label{sub:local_storage}
To ensure that the data stored on the Android device we decided to look at different options for storing data encrypted on the device. Firstly, we considered the SQLite database that is natively supported by Android. The problem with using SQLite is the fact that we would have to create a schema for each of the sensors and their datatypes, making it a longsome task, and the process of adding new sensors would also become more tedious making the system less adaptable to new sensors. Furthermore to ensure encryption on a SQLite database we would have to use an extension to SQLite called SQLCipher\footnote{https://www.zetetic.net/sqlcipher/} which would allow us to encrypt the database. 
\\\\
Another option that we looked at was android-simple-storage (ASS)\footnote{https://github.com/sromku/android-simple-storage}, which, as the name implies, is a simple library for handling the internal (storage reserved for an application and only accessible through the application it is reserved for) and external (SD card or other shared storage) storage in Android. ASS allowed us a simple interface to this filesystem while at the same time it made it possible to encrypt the data directly through the library by specifying a few options. We therefore tried to implement a prototype of this as our main storage for the application. 

\todo[inline]{Beskriv hvorfor vi ikke valgte android simple storage}

Lastly, we came across realm\footnote{https://realm.io/}, which the developers behind it says should be the replacement for SQLite, and not just an ORM on top of it. Realm uses its own persistence engine, and is cross-platform (IOS/Android) meaning that the same realm file can be shared across multiple platforms. Realm natively supports encryption of the data. We ended up choosing Realm for our persistence layer. One of the drawbacks of realm is that it utilizes inheritance to specify which objects should be able to be stored persistently. This restriction makes it such that we cannot our self implement an inheritance hierarchy or similar, where inheritance is involved. Another drawback is the fact that realm only support certain kinds of lists, \mono{RealmList}, and does not support types such as maps or enums, forcing us to either encode and decode it in a certain way such that we save it in a string or similar or create a class wrapper that can can contain the simple types of the map or enum.

\todo[inline]{Overvej at indsætte nogle kode eksempler på realm encryption, storing, og deletion her og beskriv dem}

\subsubsection{Encryption Keys}
\label{sub:encryption_keys}
A requirement when storing sensitive data encrypted is that the encryption key is not stored on the same unit as the data. Initially we stored the encryption key in the source code of the application to simplify the encryption of the data. A problem with this approach and the reason why it is a requirement to store it separately is that if an APK\todo{skal det beskrives hvad er?} of the application is publicly available it can be decompiled and the encryption key could potentially be found. All that is needed for a potential attacker or malicious application is then to somehow get access to the internal storage of our application and fetch the realm file. In most cases this is not possible unless there is a security hole in Android operating system, or that the user of the device has it rooted in which case it is possible to access the internal storage of every application on the device. An application or user with root privileges could then access our storage and with the use of the key found in the decompiled APK gain access to all the sensitive information that we store on the device.
\\\\
Instead of storing the encryption key on the device we decided to move it to the server, and actually also ensure that every device has its own encryption key. Having an encryption key for each device requires us to somehow be able to uniquely identify a device. 
\todo[inline]{Har vi skrevet om device id her?}
In having the device identifier it is possible for us to generate a 512 bit random encryption key the first time a certain device requests our server and then simply return the newly generated key or a stored key if one has already been generated for the given device. We generate the key with the algorithm seen in \lstref{lst:encryption_php}. 

\lstinputlisting[
   style = PHP,
   caption = {The algorithm generating encryption keys.},
   label = {lst:encryption_php},
]{content/security/code_snippets/encryption.php}

The algorithm utilizes the random number generation features in the linux kernel, by utilizing a special file, \mono{/dev/urandom} that interfaces the random number generation. Each time this file is read by the algorithm it will return a random byte, making it ideal to generate a sequence of random bytes representing an encryption key. The algorithm firstly create a file pointer to the \mono{/dev/urandom} file with the \mono{fopen} function. The function will return \mono{FALSE} if the file could not be opened, which is checked in \lineref{lst:fp_check}. Next, we will read the number of specified random bytes with the \mono{fread} function, which we will then return back to the call site as a binary string. The string is however not readable or easy to decode if it was send as is. Instead we convert it to a hex encoded string. 

\todo[inline]{Describe how we retrieve and decode the key on the Android client}

\subsection{Remote Storage}
\label{sub:remote_storage}


\todo[inline]{Describe how we should encrypt the data on the remote storage}