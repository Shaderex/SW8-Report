%!TEX root = ../../super_main.tex

\chapter{Conclusion}
\label{cha:conclusion}
Reality mining is an area of research focused around collecting and studying data about human dynamics. A problem that we ourselves and many others have had is the fact that such data is not easy to come by. We wanted to develop a context aware application, but were not able to find any suitable data. This project originates from these difficulties. The problem statement is reproduced here for the reader's convenience:
\\
\input{content/problem_analysis/primary_question}
\\\\
We have designed and implemented a solution, uMiner, which allows customers to create customized campaigns for collection of labeled training data. The labeled training data is returned to customers in a readable JSON format, which should allow easy conversion to a format suitable to the customer's machine learning problem or other needs. The implemented system utilize a client server architecture, where the server provides data for two different clients, namely a native Android application and a web application. The server is also used for receiving the upstream of the data gathered on the Android client, through a RESTful API that ensures that the solution is scalable. The web application is used by the customers of our system, who should be able to configure what data is collected from the Android application, but also retrieve the gathered data. The Android application is split into two parts, a front-end and a background service. The front-end is designed to allow participants to join campaigns and answer related questionnaires, which are used to label the collected data. The background service is the backbone of the data gathering. It is responsible for the automated collection of sensor data from both sensors in a smartphone and sensors in a smartband, as well as activating the questionnaires in a timely fashion.  
\\\\
We have through use of different mechanics in the Android framework implemented an Android application that enables us to gather data from multiple sensors in parallel. This along with the selected client server architecture allows for distributed gathering across multiple devices. The architecture allows us to easily add new sensors in a smartphone or wearable. We handle the problem of missing sensors by explicitly checking for their presence before requesting data from them. Data from a sensor that is not available is simply just not included in the data returned to customers. It is then up to customers to make sense of the collected data and filter it to their liking.
\\\\
Through the use of questionnaires, we have attempted to label the data gathered by our system. Customers can specify a series of zero or more binary questions, which will be asked periodically and attached to the data gathered in this period. The answers to these questions are able to serve as a label of the data gathered. Customers are able to specify these questionnaires as well as the format of the data they want collected. Customers can specify precisely which sensors or data sources they want to include, and different levels of timings for when data should be read. These timings are used for the structure that we have designed for the data. We have introduced several concepts such as \emph{snapshots}, \emph{samples}, and \emph{measurements}. These concepts are used to describe the multi-leveled structure that was implemented to capture the temporal nature of sensor data. The structure should allow the customer to gather the data that they need, but will also reduce the battery and network consumption on the participants' devices by reducing the amount of data collected. We have shown that the data that we gather can be utilized to create simple classifiers even though we structure the data in this way, indicating that it should be possible to use the data in more advanced cases.
\\\\
We have taken several measures to minimize the effect that our client application has on participants' daily lives that involves the use of smart devices. We have been concerned with the battery life of the participants' devices; the network usage; and the general disturbance that might be caused by the questionnaires that the participants have to answer. We have laid out how the efficiency, in terms of battery consumption, of the implemented application can be optimized and we have implemented some battery and network consumption optimizations, such as batching network requests and restricting uploading of the collected data, to be done using Wi-Fi instead of mobile networks. The architecture of the Android application also helps the Android operating system manage resources better, by splitting the application into a front-end and a background service. We have furthermore made some efforts to decrease the size of the gathered sensor data on the devices, by implementing a structure to handle a common data type that is measured by multiple sensors. The questionnaires are presented to the participant through Android notifications which allows the user some degree of configuration of how and when they want to be disturbed in order to answer questionnaires. % We have tested this
\\\\
The privacy of participants is maintained through various encryption techniques, such as AES and SSL. These are utilized when storing and transmitting data. This ensures that the values can never be read on the disk or during transfer, and we therefore follow most of the statutory demands imposed by the Danish Data Protection Agency. 
\\\\
In general we deem the uMiner platform to be a viable product for customers that are interested in getting access to reality mining data. By the specification of campaigns and the seamless gathering of snapshots done in a secure, resource aware and non intrusive way, we think that uMiner helps alleviate the burden of gathering reality mining data.


% We are generally satisfied with the developed product, but see some areas where further development would be beneficial.

% den prøver at løse problemet
% der er plads til forbedringer

% architectur der fungere og er let at udvide
% struktur