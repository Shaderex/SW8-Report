%!TEX root = ../../super_main.tex

\section{Compression}
\label{sec:compression}
We will also need a model for the gathered data to complement the specifications of how the individual snapshots should be composed. This model should be able handle different types of data from different sensors. Some measurements will be simple floating point numbers, to approximate real numbers, and others will consist of more complex types aggregating different values possibly of different types.

\todo[inline]{This introduction does not match very well here. Re-write!}

\todo[inline]{Describe other methods we used for compression here!}

\subsection{Compression of Floats}
As described in \secref{sec:general_strategies}, we would like to minimize the power consumption of our application. To do this, we minimize the footprint of the collected data when transmitting it wirelessly, since this is very expensive. To do this, we compress values gathered from sensors. Many sensors will make measurements described by three \mono{float} values. We designed a class called \mono{FloatTripleMeasurement} which is used to compress these three values a single \mono{long}, meaning we convert $12$ bytes ($3 \times 4$ bytes) to be stored in $8$ bytes. We do this by sacrificing some of the precision of a regular float.
\\\\
When compressing, we assume that the integer part does not exceed $7$ numbers. We do this because the sensors only produce values ranging from $-360$ to $360$. We strip the decimal separator from the floats and treat them as a $20$ bit integer value, where the first bit determines whether the value is positive or negative. This means that we now use $60$ bits for storing the compressed value of the floats. We use the remainder of the long to add 3 bits for representing where the decimal should be placed. A visualization of the method used to compress floats can be seen in \figref{fig:float_triple_convert} and \figref{fig:float_triple_bit} respectively.
\begin{figure}[!htbp]
    \begin{alignat*}{6}
       &8.138   &&                   &&   && 8138  &&                   && \text{\mono{00000001111111001010}} \\
      -&12.821  && ~~ \rightarrow ~~ && - && 12821 && ~~ \rightarrow ~~ && \text{\mono{10000011001000010101}} \\
       &42.4878 &&                   &&   && 42487 &&                   && \text{\mono{00001010010111110111}} 
    \end{alignat*}
    \caption{Compression of floats.}
    \label{fig:float_triple_convert}
\end{figure}

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=\textwidth]{graphic/gathering_sensor_data/float_triple_bit.pdf}
    \caption{The bit representation of a FloatTriple.}
    \label{fig:float_triple_bit}
\end{figure}
We wanted to compress the floating point values of the sensors so that the size of the data we need to send over network and store on the device would decrease. However, this compression does not come for free. We actively make a trade off between size of data stored and CPU cycles used for compressing and decompressing the values. We have conducted a performance test for our compression of floats that investigates how much extra time has to be spent on compressing and decompressing the floats. In the test we create a number of arrays that each contain three float values. The actual test is how fast the three float values can be multiplied together. We do this in two ways: One where we compress and decompress the float values first, and another one where we just multiply. This can give us an indication of how much time is lost on the compression when performing another task. The results of the test can be seen in \tabref{tab:results_of_compression_test}.

\begin{table}[!htbp]
\centering
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{|l|l|l|l|l|l|l|}
            \hline
            ~ & \multicolumn{3}{|c|}{1+ One} & \multicolumn{3}{|c|}{Nexus 5 } \\ \hline
            Count    & \begin{tabular}[c]{@{}l@{}}With \\ compression\end{tabular}  & \begin{tabular}[c]{@{}l@{}}Without\\ compression\end{tabular} & Ratio & \begin{tabular}[c]{@{}l@{}}With \\ compression\end{tabular}   & \begin{tabular}[c]{@{}l@{}}Without \\ compression\end{tabular} & Ratio \\ \hline
            10000   &   83 ms   &   11 ms   & 7.55  &   77 ms   &   10 ms   & 7,70  \\ \hline
            100000  &  635 ms   &  172 ms   & 3.69  &  783 ms   &  113 ms   & 6,93  \\ \hline
            1000000 & 9088 ms   & 1333 ms   & 6.82  & 8245 ms   & 1090 ms   & 7,56  \\ \hline
        \end{tabular}%
    }
    \caption{Results of compression test}
    \label{tab:results_of_compression_test}
\end{table}
\FloatBarrier

As can be seen in \tabref{tab:results_of_compression_test}, it generally took seven to eight times as long to perform the multiplication when we used compression and decompression. It is, based on these results, pretty obvious that rather many CPU cycles will have to be spent on this. With this in mind, one has to consider if these extra CPU cycles, extra battery usage, etc, is worth the tradeoff. On one hand, it is possible to spend additional CPU cycles and power before storing data on the device, in order to save 1/3 of the space, while having to transfer less data to the server and thereby spending less power and CPU cycles on this. On the other hand we could save all the power before storing, just save the normal floats in the database, and then have to spend extra power for transferring because there is simply more data. We do not know if our approach uses more power than simply not doing it, but if the system should be expanded into something large scale, it should definitely be checked. One thing that we can definitely know for sure is that our approach uses less disk space, which is also something to consider. 
\\\\
There are furthermore the considerations of how modern compression algorithms will handle our single long compared to the three floats. One can imagine that the three floats are compressed better by external compression algorithms than the long is, and that we therefore don't have as good compression during the transfer of data to the server, which is bad because the participants have to spend more of their data limit to send the data to us. In Android the standard class for sending HTTP requests automatically compresses requests to a format called GZIP, so we could spend some time figuring out if our FloatTripleMeasurement are better than three floats for transferring, but we decided against it, due to lack of time. 