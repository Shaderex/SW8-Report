%!TEX root = ../../super_main.tex

\section{Background Sensor Service}
\label{sec:background_sensor_service}
\todo[inline]{LÆS HERFRA} 
The primary purpose of uMiner is the collection of the sensor data. In order to collect the data, we need to somehow have the gathering of the sensor data to run at all times, when a participant has joined a campaign. It would however be unpreferable to force the participants to have our application open at all times, making them unable to utilize their device for anything else. We have therefore chosen to implement an Android service, called \mono{BackgroundSensorService}. 
\\\\
A service is an application component, which encapsulates a long running background task. A service can run in the same process as the graphical interface shown to users, but also in a separate process. We have chosen to run our service in a separate process, because it is ideal for data collection, since we in this way can reduce memory usage when the GUI elements are not presented on the screen. Even though we run our service in a separate process we should still be able to communicate with it from the graphical application. Luckily, the Android framework supports two-way message parsing as a way of communicating with a service. Message parsing makes it easy for the graphical application to communicate with our service.
\todo[inline]{LÆS HERTIL} 

% Boot receiver
% On Application start
\subsection{Service Start}
\label{sub:service_start}
Our service should as previously ideally always be running, which does not imply that it is constantly using processing resources. We have implemented two measures to ensure that the service is running for as much time as possible. The first measure is an Android \mono{BroadcastReceiver}, which upon receiving a system wide \emph{boot completed}-broadcast, starts the service. The second measure involves attempting to start the service every time the graphical application is started. It will, however, not start if it is already running.

\subsection{Snapshot Generation and Upload}
\label{sub:background_sensor_service_snapshot_generation_and_upload}
In order to generate snapshots, as mentioned in \ref{sec:modeling_sensor_data}, we should signal different \emph{sensor providers} to start collecting data. This should be done periodically, depending on the configured campaign. To do this, we use a timer, which is encapsulated in a class called \mono{SnapshotTimer}, which is started whenever the service has an active running campaign. Tasks, which utilizes our sensor providers to generate snapshots, are then scheduled by this timer at a constant rate, until the campaign is completed or stopped by the participant.
\\\\
Before we send all generated snapshots to the server we transform them to a JSON format. We have chosen to utilize the JSON format because it is human readable, making it easier for us to debug; it is decent for machine learning purposes; and it is a common format which natively can be interpreted by the PHP code on our server. Choosing JSON is in this way convenient, however it is at the sacrifice of spending extra bandwidth for sending the data, which is rather inconvenient for the participants. A better solution would be to use some format with few-to-no keys, where we have optimized how much space we use. 
\\\\
When we have converted the data to JSON, the actual upload of snapshots is done separately and is encapsulated in a class called \mono{SynchronizationManager}. The upload should ideally be done using as little network resources as possible, and thereby also reduce power and bandwidth consumption. 
\\\\
\todo[inline]{Her er en teknisk detalje (spørg Marhlder), som skal skrives ind i overstående. Det skal nok ikke forklares så meget i dybden. Fortæl istedet hvad en threadpool er, og hvad vi får ud af at bruge den! 
% indsæt newline her
The \mono{BackgroundSensorService} is configured to have one thread available per sensor type, i.e. per \mono{SensorProvider} specialization (see \secref{sub:providing_sensor_data_implementation}), used in the service. This lets the scheduling of the gathering from the different \mono{SensorProvider} instances up to the underlying Java implementation of threads in a hope to run the different types of sensors and other data sources as independently as possible. Data is only collected from the \mono{SensorProvider} instances if the corresponding sensors are included in the currently active campaign and if the system is currently gathering a snapshot. There is no data collection activity in the \mono{BackgroundSensorService} unless a timed task for a snapshot is running. 
% indsæt newline her
CPU resources, and thereby battery, are therefore only consumed on demand. We do not provide any real time guarantees but the different threads from the different streams of data should always be able to run unless they get starved by other processes in the system. Temporary starvation of the data collecting threads might result in missed updates from different data sources.}

\todo[inline]{Omskriv følgende paragraf til at beskrive hvad vi har gjort, og hvad vi har brugt den til konkret. Start med at forklare problemer med kommunikation over netværk (ref til general strategies i problem analysen). jvf. Holms rettelser, så brug gerne: The \mono{GCMNetworkManager} incorporates radio based optimizations and will start all the pending tasks if the radio is active and a minimum time, specified by the parameters, has elapsed. This minimizes unnecessary wake-ups of the radio and thus minimizes battery consumption}

An example of an Android API, or rather a library with Google APIs for Android, which could help optimize network usage, and the, would be the \mono{GCMNetworkManager}, which is an Android service, that can schedule encapsulated network tasks. \mono{GCMNetworkManager} \parencite{gcmnetworkmanager} handles batching of network tasks; retries; backoffs, in case a remote server is not responding or is busy; waiting for Wi-Fi, for bandwidth heavy communication; waiting with communication until the device is charging; and waiting until a radio becomes active, for instance by getting activated by another application. It does all of this based on parameters given to every encapsulated network tasks such as a desired time frame for the network communication and desired network or battery conditions.  
\\\\
Our \mono{SynchronizationManager} uses the \mono{GCMNetworkManager} to schedule a periodic task which attempts to upload gathered snapshots to the server. Our periodic task is configured to override the old pending tasks if it is rescheduled, but has not yet been executed. It is then up to the \mono{GCMNetworkManager} to determine when the task should be executed based on parameters specified when the task is defined. Our task is configured to require that an unmetered connection, e.g. Wi-Fi, is available before the task can be executed, since participants might not be willing to pay for data transfer of the snapshots. 
\\\\
Using \mono{GCMNetworkManager} makes sense for network related operations, which can be delayed in order to minimize battery consumption. Other network tasks which should happen instantly, such a refreshing the GUI with lists of campaigns from the server, are therefore not applicable to be optimized with \mono{GCMNetworkManager}. 

\subsection{Concurrency Overview}
We have attempted to give an overview of the processes and threads running in the mobile application in \figref{fig:system_currency_and_lifecycle} illustrated with an activity diagram. We provide this overview in a hope to make the communication between the different processes and the interaction between threads in the application more clear.
\\\\
The system is split into two parts, as illustrated in the figure, namely an \emph{Android Application Process} part (GUI), and a \emph{Background Sensor Service} part. The Android application is further split into two activities, namely the \emph{Main Activity} and the \emph{Questionnaire Activity}. As seen in \figref{fig:system_currency_and_lifecycle} the \emph{Main Activity} lives until the participants closes it. The participant is, during the life cycle of this activity, able to subscribe to, and unsubscribe from campaigns. Like the \emph{Main Activity}, the \emph{Questionnaire Activity} lives until the questionnaire within is answered. However, the \emph{Questionnaire Activity} might also expire if the delay from the \emph{Upload Delay} timer elapses before the participants have answered, or if the participants have dismissed the questionnaire. Both the \emph{Main Activity} and the \emph{Questionnaire Activity} is started by an \emph{Intent Handler} as seen in the middle left in \figref{fig:system_currency_and_lifecycle}. The \emph{Start Main}-receiver, which starts the \emph{Main Activity}, is signaled when the user opens it, for instance by clicking the application icon from the launcher (home screen) of the device. The \emph{Start Questionnaire}-receiver is signaled, and thereby started, by the Background Sensor Service.
\\\\
The \emph{Background Sensor Service Process} is the main process of the application. It is responsible for ensuring that the collection of snapshots is done accordingly to the campaign specified. This service is started, as seen in the top right corner of the service in \figref{fig:system_currency_and_lifecycle}, by the \emph{Application Start}-signal or by the \emph{onBoot}-signal, if it is not already running. These signals are sent when the application is installed or after the device boots, respectively, as covered in \secref{sub:service_start}. 
\\\\
The service starts two asynchronous tasks: a task for gathering snapshots, which is the most complicated part of this process; and a task for uploading the snapshots to the server, as described in \secref{sub:background_sensor_service_snapshot_generation_and_upload}. The first task, the synchronization task, checks if there are any snapshots ready to be uploaded at every \emph{Synchronization Delay}, as seen in the lower left of the figure. The second task first checks if there are any active campaigns on the device, and will continue to start gathering samples from the sensor specified for that campaign and signal the \emph{Questionnaire Activity} to prompt the participant for labels, if this is the case. Data collection can also be started at any time, if a participant joins a campaign. The \emph{Questionnaire Activity} is only signaled to start, if the campaign actually includes questionnaires, as questionnaires are optional. The sample is stored on the device when the gathering is completed. Answers to questionnaires are attacked to the the corresponding snapshot whenever a questionnaire is answered. These stored snapshots are now ready to be uploaded by the \mono{SynchronizationManager}. The task goes back to the \emph{Active Campaign}-state whenever a sample has been completed, and it will continue to do so until it has gathered enough snapshots.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{graphic/backgroundsensorservice/lifecyclestuff}
    \caption{An overview of the mobile Application Components.}
    \label{fig:system_currency_and_lifecycle}
\end{figure}
\FloatBarrier