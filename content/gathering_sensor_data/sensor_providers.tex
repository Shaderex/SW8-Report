%!TEX root = ../../super_main.tex

\section{Providing Sensor Data}
\label{sec:providing_sensor_data}

To support this structure of the sensor output, we have designed an abstraction over the different sensors available. This abstraction is designed for concurrent collection of samples, as we want the application to be able to gather information from multiple sources at the same time, meaning that the system is able to, for instance, collect data regarding the motion and location of the participant simultaneously. This is done in order to make sure that the gathered data is obtained according to the desired temporality of the customer, i.e. the time constraints of the campaign as seen in \figref{fig:sample_temporality}.
\\\\
As described in \secref{sec:deriving_the_context_from_sensors}, there exist various types of sensors, each sensing various types of data in various formats. Problems will arise when enforcing temporality of snapshots due to the event oriented nature of sensors in Android. Sensor events will trigger whenever a value is updated. This effectively means that it is impossible to know when these events will trigger. We want to guarantee that measurements can be made with a specific frequency independent on what is supported by the sensor, i.e. measurements can be made more often than what some sensors provide, but also more rarely. For instance the nature of an accelerometer sensor (in Android at least) is that it only raises an event whenever the device is affected in some way, meaning that if the phone is laying completely still this event may never be raised. For sensors of this nature, we need to have some cache that always contains the last measurement of a sensor. 
\\\\
The idea is that this update is completely independent from the the rest of th system, meaning that this update can happen asynchronously. \figref{fig:cache_examples} shows how this independent behavior provides an interface time driven processes that want to acquire the data synchronously. \figref{fig:cache_no_event_between} shows a scenario where some other process request a measurement multiple times where the events from the sensors are not triggered in between. As shown this process will be answered with the same value in both of its requests. However since the underlying sensor have not registered a change the cached measurement must still be correct. Another scenario, as shown in \figref{fig:cache_multiple_event_between}, is that multiple events are triggered between two measurement request from another process. Also here the interface is sound since the value of the sensor that is most recent will be returned, effectively providing the eaves drop interface on event driven sensors we desire.

\begin{figure}[!htbp]
\begin{subfigure}[!t]{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{sensor_providers/cache_example_1}
  \caption{No events between requests.}
  \label{fig:cache_no_event_between}
\end{subfigure}
\begin{subfigure}[!t]{.5\textwidth}
  \centering
  \includegraphics[width=\linewidth]{sensor_providers/cache_example_2}
  \caption{Multiple events between requests.}
  \label{fig:cache_multiple_event_between}
\end{subfigure}
\caption{Measurement caching.}
\label{fig:cache_examples}
\end{figure}
\FloatBarrier

One issue this design might introduce is that we rely on these sensor events to be raised eventually. If this is not the case the cache must contains some default value for a sensor which potentially pollute the sensor measurements until the first event is triggered. This means that until the first event is raised other processes will be answered with some default values. Other type of sensors such as GPS is, as mentioned in \secref{sec:deriving_the_context_from_sensors}, required on demand meaning that we are able to require the GPS location at any given time, meaning that they already provide the behavior that is desired. Some of these on demand sensors might take some time to acquire the information for instance triangulation of satellites for GPS. A potential problem here, in regards to timing, is for this reason latency of which the underlying operating system has before data from this type of sensors are returned to the caller.

\subsection{Sensor Provider}
\label{sub:providing_sensor_data_implementation}
We have implemented an abstract class called \mono{SensorProvider}, which must be specialized for each type of sensor available, both for sensors found in Android, but also for sensors found in the Microsoft Band 2. The abstract class provides functionality that makes it easy to implement specialized implementations for every sensor that we have. Sub-classes of the abstract \mono{SensorProider}, must specify a generic argument, \mono{MeasurementT}, describing the type of measurement that the implementation will make. Besides this, the following methods must also be implemented on the specializations:

% The common interface for these sensor providers is implemented by the following methods:

\begin{description}
	\item[\mono{boolean isSensorAvailable()}] Should return \mono{true} if the sensor is currently available, and ready to take measurements. Should return \mono{false} if the sensor is unavailable or not present on the device.

	\item[\mono{SensorType getSensorType()}] Should return the \mono{SensorType} that the sensor provider implementation will utilize. For instance \mono{SensorType.BAROMETER}.

	\item[\mono{EventListenerRegistrationManager createRegManager()}] Should return an instance of something that implements the \mono{EventListenerRegistrationManager} interface. This interface will enforce the class to implement the following two methods: \mono{void register(int frequency)} and \mono{void unregister()}. These methods will be used by the \mono{SensorProvider} implementation to register the sensor (and its event listeners) when the specific sensor is needed, and unregister them when they are not.

  \item[\mono{FloatTripleMeasurement getDefaultMeasurement()}] Should return an default instance of the \mono{MeasurementT} that the subclass is parameterized with.

\end{description}

Besides implementing these methods, the specializations must also call the \mono{void onNewMeasurement(MeasurementT)}, which will override the cached value, as described in \figref{fig:cache_examples}. With these measurements registered, the \mono{SensorProvider}, and in effect all of the sub-classes, are now able to construct \mono{Sample} objects by reading measurements from the cache with the specific intervals. 
\\\\
All of this effectively means that new sensors can be implemented into the system with very few lines of code. An example of such an implementation can be seen in \lstref{lst:sensor_provider_acclerometer}, which shows how the \mono{AccelerometerSensorProvider} implements and uses the methods described above to make measurements from the phones accelerometer available to our application. The developer have to write relative few lines of code to enable this provider for a any new type of sensor. To do so the developer must, as seen in \lineref{line:sensor_provider_extends}, subclass the \mono{SensorProvider} with the generic parameter \mono{FloatTripleMeasurement} which is the type of measurement the accelerometer produces. Furthermore he have to override the abstract methods as follows: \linesref{line:isSensorAvailable_start}{line:isSensorAvailable_end} for the \mono{isSensorAvailable}, \lineref{line:getSensorType} for \mono{getSensorType}, \lineref{line:createRegManager} and \linesref{line:createRegManager_start}{line:createRegManager_end} for \mono{createRegManager} and lastly \lineref{line:getDefaultMeasurement} for \mono{getDefaultMeasurement}.

\lstinputlisting[
   style = Java,
   caption = {Implementation of sensor provider for Accelerometer.},
   label = {lst:sensor_provider_acclerometer},
   float=!htbp,
]{content/gathering_sensor_data/code_snippets/sensor_provider_acclerometer.java}
\FloatBarrier

\subsection{Gathering Data from the Microsoft Band 2}
Due to the structure of sensor providers, as described in \secref{sub:providing_sensor_data_implementation}, it is relatively easy to implement functionality that will gather information from the Microsoft Band 2 smart watch. The only major difference between the Microsoft Band sensors, and the ``default'' Android Sensors, is the fact that a connection between the watch and the phone has to be made. This connection has to be made in all of the band sensor providers; due to this, we implemented an abstract class called \mono{SensorProviderBand}, which implements the method \mono{getConnectedBandClient()} which will try to establish a connection to the watch, through the required Microsoft Health application. The method can be seen in \lstref{lst:get_connected_band_client}. The method return a boolean, indicating if the connection were established or not. However, currently, we do not do anything specific when the connection fails, and we simply try again at a later point in time.

\lstinputlisting[
   style = Java,
   caption = {Establishing a connection between the phone and watch.},
   label = {lst:get_connected_band_client},
   float=!htbp,
]{content/gathering_sensor_data/code_snippets/get_connected_band_client.java}
\FloatBarrier
