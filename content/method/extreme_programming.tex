%!TEX root = ../../super_main.tex

\section{Extreme Programming}
\label{sec:extreme_programming}

In this project we have chosen to adopt most of the aspects from XP, which is a type of agile software development method, that has a high amount of focus on customer satisfaction, developer productivity/welfare and high product quality \parencite{xp}. The method focuses on delivering partial products to the customers in a, by the customers, prioritized order, instead of just a complete product far in the future. This is in XP normally achieved by use of several core practices, such as: on-site customer, test driven development, pair programming, planning poker, continuous integration and delivery, and daily meetings. XP emphasizes the value of \emph{simplicity}, \emph{communication}, \emph{feedback}, \emph{respect}, and \emph{courage}. 

\begin{itemize}
    \setlength\itemsep{-0.2em}
	\item \emph{Simplicity} is about taking the simplest path to delivering a minimum viable product without compromising quality. 
	\item \emph{Communication} between every member of the team, including the on site customers, is essential to deliver a product that everybody is proud of. 
	\item \emph{Feedback} should be taken seriously, and demonstrations should be done early in the process and frequently.
	\item \emph{Respect} between the team members, the customers, and management is important.
	\item \emph{Courage} allows the team to take on new challenges without the fear of failing, because nobody works alone. The developers should have the courage to tell the truth about progress and estimates. 
\end{itemize}

The following sections describe some of the basic concepts from the XP method that we chose to use, how we planned to implement them, and some of the conflicts between our project and the method.

\subsection{Iterations}
\label{sub:iterations}
Extreme Programming encourages rather short iterations in comparison to other agile development methods. The iterations are of constant length and should be between one to three weeks. Because of their constant length they can be used to track the progression and the velocity of a project, by evaluating the amount of work done in the end of an iteration, compared to the estimates given to the tasks in the given iteration. 
\\\\
In our project we chose to have iterations of two weeks (calendar time) in length. Each of these ended with a review of what we had managed to accomplish in the given iteration. One of the issues with using calendar time to schedule our iterations is that we had to follow the courses of the semester as well. This made the amount of time we had available vary between the different iterations, making it more difficult to estimate how much we could complete in each iteration. To try to alleviate this issue we calculated the amount of time we had in a given iteration, and took that into consideration when planning it. 

\subsection{Releases}
XP encourages frequent and small releases to the customers. Each iteration ends with a deliverable in XP and these deliverables can be evaluated by the customer, who can then decide if it should be taken into production. The idea behind frequent releases is, that the earlier the functionality is used by the customers, the sooner any potential bugs can be found and fixed by the developers. Furthermore, it allows the customers and the team to evaluate if the project is on the right track.
\\\\
We chose to produce a release every second XP iteration, meaning that we produced a release every four weeks. For each of the releases we created a major product release, but we also built a minor product release for iterations that did not end in an XP release, if the product was accepted by the customer at the given time. This meant that we released a new minor version, if the corresponding acceptance tests passed for the given iteration. All releases have been pushed to our \href{https://github.com/Shaderex/SW8-Android/releases}{GitHub Page}\footnote{\url{https://github.com/Shaderex/SW8-Android/releases}}.

\subsection{Taskboard and User Stories}
\label{sub:taskboard_and_user_stories}
An XP release plan is created for each release, during a release planning meeting. The release plan is typically represented on a taskboard by the use of user story cards and task cards. An example of our taskboard during an iteration can be seen in \figref{fig:taskboard}.

\begin{figure}[!htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{method/taskboard.jpg}
    \caption{A picture of our taskboard.}
    \label{fig:taskboard}
\end{figure}

The user story cards are made in collaboration with the customer during release planning.  A subset of all the stories will then be selected to be completed in the given iteration, and acceptance tests will be made for these stories. An acceptance test is a specific test that is conducted in order to determine whether a user story, i.e. a part of the specification, is satisfied. An example of a user story and corresponding acceptance test can be seen in \tabref{tab:user_story_acceptance_test_example}. The rest of the user stories and acceptance tests can be found in \appref{app:user_stories_and_acceptance_test}.

\begin{table}[!htbp]
    \centering
    \begin{tabular}{| m{0.45\textwidth} | m{0.45\textwidth} |}
        \hline
        \textbf{User Story} & \textbf{Acceptance Test} \\ \hline
        As a customer, I would like to get answers from questionnaires generated by me from participants & 
        \begin{itemize}[noitemsep,parsep=0pt,partopsep=0pt]
        \item When a customer can come up with a questionnaire, get it into the system without writing code, and have it answered by a participant.
        \item The questions must occur in sequence and it should only be possible to answer yes or no.
     \end{itemize} \\ \hline
    \end{tabular}
    \caption{Example of a user story and corresponding acceptance test from our first iteration.}
    \label{tab:user_story_acceptance_test_example}
\end{table}
\FloatBarrier

We chose to attempt to follow the standard XP release plan concept by role-playing various roles from XP, because they are such a central aspect of the method. We assigned each team member roles, such as customer, tester, developer, and participant, which they had to role-play during the iteration review and planning meetings. This role-playing should make it easier for us, as a team, to create user story cards and their acceptance tests, because one team member only had one mindset during the meetings. We assumed the approach would be challenging because it can be difficult to apply a different mindset than what one is used to. This means that one team member was assigned to act as the customer during the entire review/planning meeting. As mentioned previously, another central aspect of the development is to have a representative for the customer on-site. Innovative projects, and projects in general, do not necessarily have to have a dedicated customer. This project is a student project without a customer or user, and we therefore decided to include role-play to compensate for this. The role-playing, at least from a customer perspective, is guided by the vision of the system as developed using methods from Essence, see \charef{cha:scope_of_project}.

\subsection{Knowledge Sharing}
\label{sub:knowledge_sharing}
Knowledge sharing is encouraged in XP by using different practices such as daily stand up meetings. Daily stand up meetings are short meetings where the group members share thoughts about their current progress, hardships, and successes. This allows for brief insight in the collective progress of the group. Another core practice is pair programming, where two programmers sit at the same PC and code together. Even though the main purpose of pair programming is to increase code quality, it also implicitly supports knowledge sharing between the programmers. 
\\\\ 
Knowledge sharing was important for us, because all members of the group should have insight in the product and the written report. We therefore chose to include daily stand up meetings and pair programming/writing in our process. We expected that these practices would increase the feeling of collective ownership over the project, provide a steady pace during development, and increase the quality of the project. 

\subsection{Test-Driven Development}
\label{sub:test_driven_development}
Extreme Programming emphasizes test-driven development as the only development method which ensures that the developed program works as intended, and is tested without using any shortcuts (i.e. the developer writes test-to-pass instead of test-to-fail). In previous semesters we have been lacking a structured approach to testing and evaluating during the development. Tests and evaluations have therefore previously been executed in ad-hoc fashions, which has not been as useful for us as we could have hoped. We therefore decided to employ a test-driven approach, in the hope that it would help us solve this problem, and help us achieve a more structured approach to both testing and increasing code quality.

\subsection{Documentation}
A major part of the XP method is to maintain focus on development and not documentation. Documentation is only considered in XP if it gives the customer value. This is a very counter-intuitive approach for a student project, because we have a requirement for the project that states necessary documentation of learning and reflection. 
\\\\
Due to the fact that XP does not not have any built in practices or techniques to produce a technical student report during development, we had to adapt our development method to include the production of such a report. We attempted to do this by having a ``miscellaneous'' user story on the task board, which was allowed to contain tasks regarding documentation, setting up the development environment, etc. However, because XP is driven by commitment, this miscellaneous user story would, based on experience from previous semesters, be filled with tasks that were less interesting to perform. For that reason we also intended to have report iterations, where these report tasks were the only ones available to work on, which ideally should deplenish them.

\subsection{Continuous Integration}
\label{sub:continuous_integration}

Continuous Integration (CI) is the practice of frequently merging all the individual works in development from separate developers, ideally several times per day. This ensures that the system is always in a stable state, such that only small changes have to be taken care of in the case that something breaks, instead of having to roll back days, weeks or even months of work. CI is especially useful in test driven development, because the tests can simply be executed when people are integrating their work, which easily ensures the quality of the product. CI systems can also be configured to run nightly builds, which ensures that the system does not break due to outside factors, and also provides the ability to run tests that take long time to run.
\\\\
We think that a stable system is a very important part of our project, and we therefore decided to establish a CI server. This server would automatically be notified about changes when we pushed our work to our version control system, and also run nightly builds. We hoped that this would make it easier for us to spot errors during the development, such that the system would be in a stable state during the entire development period. 

\subsection{Requirements}

XP is an agile non-document driven process and our requirements were therefore not explicitly listed, as they would have been in a more traditional approach such as Object Oriented Analysis and Design, which is a waterfall development method. Our requirements were instead modeled through the user stories and tests, including the acceptance tests, unit tests, and any other formal testing. The requirements were not static in our development process and they were constantly undergoing iteration and refinement. The user stories and acceptance tests are documented in \appref{app:user_stories_and_acceptance_test}, and our unit and functional tests can be found in our GitHub repository (\href{https://github.com/Shaderex/SW8-Android/}{https://github.com/Shaderex/SW8-Android/}). Non automated tests can be found in \appref{app:manual_test}.

% The user stories and acceptance test are documented in \appref{app:user_stories_and_acceptance_test} and our unit and functional tests can be found in \appref{app:cd}. Non automated tests can be found in \appref{app:manual_test}.
